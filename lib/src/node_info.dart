/// Defines the [NodeInfo] type. This value is generated by the mDNS subsystem.
library;

import "package:flutter/foundation.dart";
import 'dart:developer' as dev;

/// Creates a wrapper type for a host/port pair.

extension type HostInfo._((String, int) v) {
  /// Creates a new instance of the type given the supplied host and port
  /// values.

  HostInfo(String host, int port) : v = (host, port);

  /// Retrieves the host portion of the value.

  String get host => v.$1;

  /// Retrieves the port portion of the value.

  int get port => v.$2;

  /// Parses a string in the form "host:port" and returns it as a HostInfo
  /// value. If there is a problem parsing the string, null is returned.

  @factory
  static HostInfo? tryParse(String? s) {
    if (s?.split(":") case [String host, String tmp]) {
      final port = int.tryParse(tmp);

      if (port != null) return HostInfo(host, port);
    }
    return null;
  }
}

/// Information associated with DrMem nodes.
///
/// This information is obtained via the mDNS announcements and by querying the
/// node.

class NodeInfo {
  /// The name of the node. This name is not the network name but is the name
  /// the owner put in the configuration file.
  final String name;

  /// A string in the format "major.minor.patch" format indicating the version
  /// of the DrMem node. The app can use this to determine what features are
  /// supported by the node.
  String version;

  /// This is the location of the node, as reported in the DrMem configuration
  /// file.
  String location;

  /// An IP address / host name along with a port number with which to use to
  /// connect.
  HostInfo addr;

  /// This is a placeholder for future security. It will contain the digital
  /// signature of the node's SSL certificate. If this field is `null`, then
  /// the DrMem node uses an unencrypted socket. If it is not `null`, a TLS
  /// socket should be used (i.e. https).
  String? signature;

  /// Indicates when the node was started. If it's `null` then the entry was
  /// programmatically entered and the actual boot time is unknown.
  DateTime? bootTime;

  /// Specifies the Graphql URL endpoint used for queries.
  String queries;

  /// Specifies the Graphql URL endpoint used for mutations.
  String mutations;

  /// Specifies the Graphql URL endpoint used for subscription.
  String subscriptions;

  /// [NodeInfo] constructor.

  NodeInfo(
      {required this.name,
      required this.version,
      required this.location,
      required this.addr,
      this.signature,
      this.bootTime,
      this.queries = "/drmem/q",
      this.mutations = "/drmem/q",
      this.subscriptions = "/drmem/s"});

  /// Indicates whether the node is currently announcing itself on the local
  /// network.

  bool get announcing => bootTime != null;

  /// Marks the node as not announcing itself.

  void deactivate() => bootTime = null;

  /// Converts a [NodeInfo] object into a map which can be used to generate
  /// JSON values.

  Map<String, dynamic> toJson() {
    var v = {
      'name': name,
      'version': version,
      'location': location,
      'addr': {'host': addr.host, 'port': addr.port},
      'queries': queries,
      'mutations': mutations,
      'subscriptions': subscriptions
    };

    // If a signature is specified, save it.

    if (signature != null) {
      v['signature'] = signature!;
    }

    return v;
  }

  /// Converts a map back into a [NodeInfo] object. If there are
  /// missing fields, or a field is of the incorrect type, this
  /// function returns `null`.

  @factory
  static NodeInfo? fromJson(Map<String, dynamic> json) {
    if (json
        case {
          'name': String name,
          'version': String version,
          'location': String location,
          'addr': {'host': String host, 'port': int port},
          'queries': String queries,
          'mutations': String mutations,
          'subscriptions': String subscriptions
        }) {
      final sig = json['signature'];

      if (sig == null || sig is String) {
        return NodeInfo(
            name: name,
            version: version,
            location: location,
            addr: HostInfo(host, port),
            signature: sig,
            bootTime: null,
            queries: queries,
            mutations: mutations,
            subscriptions: subscriptions);
      }
    }
    dev.log("couldn't restore node info for $json ... dropping from list",
        name: "NodeInfo.fromJson");
    return null;
  }

  /// Determines whether the [nodeInfo] argument is a valid update to the
  /// current object. If a DrMem node gets updated, its version number may
  /// change, or, the maintainer may change the preferred IP address (so it
  /// may be accessed outside their home, for instance.) But we must do some
  /// due diligence; we don't want someone's malicious, local node overwriting
  /// the config for a personal node.
  ///
  /// An update is considered acceptable if the names are the same and either
  /// the current node hasn't defined a digital signature or it has and the
  /// replacement info has the same signature.

  bool canUpdate(NodeInfo o) =>
      name == o.name && (signature == null || signature == o.signature);

  @override
  bool operator ==(Object other) =>
      other is NodeInfo &&
      name == other.name &&
      version == other.version &&
      location == other.location &&
      addr == other.addr &&
      signature == other.signature &&
      bootTime == other.bootTime &&
      queries == other.queries &&
      mutations == other.mutations &&
      subscriptions == other.subscriptions;

  @override
  int get hashCode => name.hashCode;

  @override
  String toString() =>
      "{name: $name, version: $version, location: $location, addr: $addr, bootTime: $bootTime, queries: $queries, mutations: $mutations, subscriptions: $subscriptions, signature: $signature }";
}
